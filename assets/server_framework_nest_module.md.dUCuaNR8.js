import{_ as o,c as a,o as d,ag as t}from"./chunks/framework.XczS8JdJ.js";const u=JSON.parse('{"title":"模块","description":"","frontmatter":{"outline":[1,3],"typora-copy-images-to":"./assets"},"headers":[],"relativePath":"server/framework/nest/module.md","filePath":"server/framework/nest/module.md","lastUpdated":1738685171000}'),r={name:"server/framework/nest/module.md"};function c(l,e,s,i,n,h){return d(),a("div",null,e[0]||(e[0]=[t('<h1 id="模块" tabindex="-1">模块 <a class="header-anchor" href="#模块" aria-label="Permalink to &quot;模块&quot;">​</a></h1><p><code>Nest</code> 提供了一种模块化的方式—— <code>Module</code> 来组织和管理你的 <code>Nest</code> 程序和代码。</p><p>每个 <code>Nest</code> 应用至少要有一个根模块，作为 <code>Nest</code> 应用的入口模块，每个模块都可以看做根模块下的子模块，当这些子模块组合起来，形成一个完整的 <code>Nest</code> 应用。</p><p>默认情况下，模块就像是一个“封闭”的盒子，盒子提供了特定的工具，工具会在盒子存在期间，在盒子内共享这些工具功能。</p><h2 id="元数据" tabindex="-1">元数据 <a class="header-anchor" href="#元数据" aria-label="Permalink to &quot;元数据&quot;">​</a></h2><p>模块是具有 <code>@Module()</code> 装饰器的类。<code>@Module()</code> 装饰器接受一个对象参数，接口类型为 <code>ModuleMetadata</code> ，它有四个字段，全是数组类型：</p><ul><li><code>providers</code>：模块中所有注入的依赖列表，当前模块会共享它们。</li><li><code>contrllers</code>：控制器列表，可注册多个。</li><li><code>exports</code>：默认情况模块是封闭的，它导出模块的依赖，模块内共享使用。</li><li><code>imports</code>：导入其他模块或者其他模块的 <code>providers</code> 列表。</li></ul><p>有了这些参数，<code>Nest</code> 的 <code>IoC</code> 容器才能准确识别需要组装（注入与被注入）各种依赖关系。</p><h2 id="模块导出" tabindex="-1">模块导出 <a class="header-anchor" href="#模块导出" aria-label="Permalink to &quot;模块导出&quot;">​</a></h2><h2 id="共享模块" tabindex="-1">共享模块 <a class="header-anchor" href="#共享模块" aria-label="Permalink to &quot;共享模块&quot;">​</a></h2><h2 id="全局模块" tabindex="-1">全局模块 <a class="header-anchor" href="#全局模块" aria-label="Permalink to &quot;全局模块&quot;">​</a></h2><h2 id="动态模块" tabindex="-1">动态模块 <a class="header-anchor" href="#动态模块" aria-label="Permalink to &quot;动态模块&quot;">​</a></h2>',12)]))}const m=o(r,[["render",c]]);export{u as __pageData,m as default};
