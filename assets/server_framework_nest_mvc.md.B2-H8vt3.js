import{_ as t}from"./chunks/reqFlow.SJXRC_YF.js";import{_ as d,c as o,o as c,ag as r}from"./chunks/framework.XczS8JdJ.js";const u=JSON.parse('{"title":"MVC架构","description":"","frontmatter":{"outline":[1,3],"typora-copy-images-to":"./assets"},"headers":[],"relativePath":"server/framework/nest/mvc.md","filePath":"server/framework/nest/mvc.md","lastUpdated":1738685171000}'),a={name:"server/framework/nest/mvc.md"};function s(l,e,i,n,p,m){return c(),o("div",null,e[0]||(e[0]=[r('<h1 id="mvc架构" tabindex="-1">MVC架构 <a class="header-anchor" href="#mvc架构" aria-label="Permalink to &quot;MVC架构&quot;">​</a></h1><h2 id="概念" tabindex="-1">概念 <a class="header-anchor" href="#概念" aria-label="Permalink to &quot;概念&quot;">​</a></h2><p>架构模式是一个通用的、可重用的解决方案，<code>MVC</code> 是一种架构的思想，不是具体的实现。</p><p>模型-视图-控制器的模式，也称为 <code>MVC（model-view-controler）</code> 模式，是一种业务逻辑、数据、视图显示分离的组织代码的方式。</p><p>它把软件系统分为三个部分：</p><ul><li><code>M(Model)</code> ：负责具体的业务实现，完成对数据的查询，常见的 <code>MVC</code> 框架将 <code>model</code> 拆分为业务层、模型层。</li><li><code>V(View)</code>：展示视图，展示模型中的数据，在前后端未分离前，最具代表的就是 <code>jsp</code> 技术。</li><li><code>C(Controller)</code>：控制器，负责搜集客户端的请求，分发调度客户端的请求，处理请求和响应数据。</li></ul><p>常见的基于 <code>MVC</code> 架构模式的框架有：<code>Struts、Spring MVC</code>。</p><p><strong>一次完整的客户端请求流程：</strong></p><p><img src="'+t+'" alt="请求流程图"></p><h2 id="名词解释" tabindex="-1">名词解释 <a class="header-anchor" href="#名词解释" aria-label="Permalink to &quot;名词解释&quot;">​</a></h2><table tabindex="0"><thead><tr><th>名称</th><th>概括</th><th>用途</th></tr></thead><tbody><tr><td>PO</td><td>持久化对象</td><td>数据表映射对象，表的字段与PO对象属性一一对应</td></tr><tr><td>VO</td><td>值对象</td><td>用于业务层之间的数据传递，比如响应给客户端的数据对象</td></tr><tr><td>DTO</td><td>数据传输对象</td><td>经过处理后（增加/减少属性）的PO对象，用于跨进程或网络传输的对象载体，比如前端传过来的请求体参数</td></tr><tr><td>DAO</td><td>数据访问对象</td><td>业务层提供接口，负责与数据库进行交互，封装简单的 CRUD 方法，也就是service对象</td></tr><tr><td>BO</td><td>业务对象</td><td>对DAO封装后的对象，可以是包含一个或多个对象，比如多对多关系的BO对象</td></tr><tr><td>POJO</td><td>简单对象</td><td>基本的对象，拥有getter、setter方法</td></tr></tbody></table><hr><p>在上面花了一些篇幅介绍了 <code>MVC</code> 架构的概念，为什么需要它呢？</p><p>首先明确一点，一个应用发展到庞大的体量时，如果不进行解耦分层设计，那么带来的维护难度将是不可估量的，耦合度也很高，比如在 <code>PHP</code> 还不支持面向对象之前，这三层的代码就是杂糅在一起的，十分混乱。为了解决这个痛点，<code>MVC</code> 架构出现了，而且普遍应用于市场上的很多互联网应用程序。</p><div class="info custom-block"><p class="custom-block-title">INFO</p><p>一个架构或技术的出现，必定伴随着它的利与弊，<code>MVC架构</code> 所带来的降低项目复杂度、解耦合的优点，是建立在架构复杂的基础上，需要花费一定时间去思考设计应用架构，不利于中小型软件的快速开发，调试起来也增加了复杂度，但这不影响它是最常用的架构设计。</p></div><h2 id="mvc-在-nest-的体现" tabindex="-1"><code>MVC</code> 在 <code>nest</code> 的体现 <a class="header-anchor" href="#mvc-在-nest-的体现" aria-label="Permalink to &quot;`MVC` 在 `nest` 的体现&quot;">​</a></h2><p>默认情况下，<code>Nestjs</code> 使用 <code>Express</code> 库作为底层依赖，因此，在 <code>Express</code> 中使用的 <code>MVC</code> 模型的每种技术同样适合 <code>Nestjs</code> 。</p><p><code>Nestjs</code> 的 <code>MVC</code> 方案更接近 <code>Spring MVC</code> ，传统的模型层被拆分为了业务层-service，和数据访问层-DAO；控制器依旧扮演分发调度请求的角色，控制路由请求的进出；而视图层被淡化（因为前后端分离的缘故），但是你几乎可以在 <code>Nestjs</code> 中使用各类视图引擎，比如 <code>hbs(handlebars.js)</code>。</p><p>可以简单理解为：</p><ul><li>*.controller：控制器，用户访问时最先经过，由控制器调度分发处理任务。</li><li>*.service：业务层，由模型拆分出来，封装业务实现方法。</li><li>*.entity：持久化对象，映射数据库表的对象，和service业务层共同组成模型。</li><li>*.module：模块，组成 <code>Nestjs</code> 应用的基础应用。</li><li>*.dto：数据传输对象，比如请求传递过来的请求体参数对象。</li></ul>',20)]))}const V=d(a,[["render",s]]);export{u as __pageData,V as default};
