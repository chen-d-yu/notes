import{_ as s,c as i,o as a,ag as n}from"./chunks/framework.XczS8JdJ.js";const k=JSON.parse('{"title":"包管理工具","description":"","frontmatter":{},"headers":[],"relativePath":"server/node/basic/npm.md","filePath":"server/node/basic/npm.md","lastUpdated":1738685171000}'),l={name:"server/node/basic/npm.md"};function d(p,e,o,c,t,r){return a(),i("div",null,e[0]||(e[0]=[n(`<h1 id="包管理工具" tabindex="-1">包管理工具 <a class="header-anchor" href="#包管理工具" aria-label="Permalink to &quot;包管理工具&quot;">​</a></h1><p>包管理工具（<code>Node Package Manager</code>）是一个基于命令行的工具，用于帮助开发者在自己的项目中安装、升级、移除和管理依赖项。</p><p>它类似于<code>Java</code>的<code>Maven</code>、<code>Python</code>的<code>Pip</code>等等。</p><p>常见的包管理工具有以下这些：</p><ul><li>npm（官方）</li><li>yarn</li><li>pnpm（推荐）</li><li>cnpm</li></ul><h2 id="cli-command-line-interface" tabindex="-1">CLI（command-line interface） <a class="header-anchor" href="#cli-command-line-interface" aria-label="Permalink to &quot;CLI（command-line interface）&quot;">​</a></h2><p><code>npm</code>提供了一系列的命令行接口，这些接口能够帮助我们管理依赖包。</p><h3 id="使用" tabindex="-1">使用 <a class="header-anchor" href="#使用" aria-label="Permalink to &quot;使用&quot;">​</a></h3><p>常见的<code>npm</code>命令：</p><ul><li><p><code>npm init</code>：初始化一个新的 <code>npm</code> 项目，创建 <code>package.json</code> 文件。</p></li><li><p><code>npm install &lt;package-name&gt;</code>：安装软件包及其依赖的任何软件包。 默认情况下，任何新软件包都被安装为生产依赖项，并且会在当前目录存放一个<code>node_modules</code>。</p><ul><li><p><code>-g</code>：全局安装依赖，默认情况下，本地安装<code>npm</code>会在当前目录下安装依赖，如果加上该选项，<code>npm</code>则会将依赖安装在全局目录中，需要查看全局安装的依赖路径，可以使用<code>npm config get prefix</code>。全局安装的依赖，一般是依赖提供的<code>CLI</code>需要被所有工程可用才采用全局安装。</p></li><li><p><code>-save</code>：默认情况下，任何新依赖包都被安装为生产依赖项，会被添加到<code>package.json</code>的<code>dependencies</code>列表中，并在打包后也需要这些依赖包的参与。</p></li><li><p><code>-dev</code>：表示将新添加的依赖包，添加到<code>package.json</code>的<code>devDependencies</code>列表中，该列表的依赖，只会参与开发阶段。</p></li></ul></li><li><p><code>npm update &lt;package-name&gt;</code>：更新指定的包。</p></li><li><p><code>npm uninstall &lt;package-name&gt;</code>：卸载指定的包。</p></li><li><p><code>npm run &lt;script-name&gt;</code>：执行 <code>package.json</code> 文件中定义的脚本命令。</p></li><li><p><code>npm search &lt;keyword&gt;</code>：搜索 <code>npm</code> 库中包含指定关键字的包。</p></li><li><p><code>npm info &lt;package-name&gt;</code>：查看指定包的详细信息。</p></li><li><p><code>npm list</code>：列出当前项目中安装的所有包。</p></li><li><p><code>npm outdated</code>：列出当前项目中需要更新的包。</p></li><li><p><code>npm audit</code>：检查当前项目中的依赖项是否存在安全漏洞。</p></li><li><p><code>npm login</code>：登录到 <code>npm</code> 账户。</p></li><li><p><code>npm logout</code>：注销当前 <code>npm</code> 账户。</p></li><li><p><code>npm publish</code>：发布自己开发的包到 <code>npm</code> 库中。</p></li><li><p><code>npm link</code>: 将本地模块链接到全局的 <code>node_modules</code> 目录下</p></li><li><p><code>npm config list</code> 用于列出所有的 npm 配置信息。执行该命令可以查看当前系统和用户级别的所有 <code>npm</code> 配置信息，以及当前项目的配置信息（如果在项目目录下执行该命令）</p></li><li><p><code>npm get registry</code> 用于获取当前 <code>npm</code> 配置中的 <code>registry</code> 配置项的值。<code>registry</code> 配置项用于指定 <code>npm</code> 包的下载地址，如果未指定，则默认使用 <code>npm</code> 官方的包注册表地址</p></li><li><p><code>npm set registry</code> <code>npm config set registry &lt;registry-url&gt;</code> 命令，将 <code>registry</code> 配置项的值修改为指定的 <code>&lt;registry-url&gt;</code> 地址</p></li></ul><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>安装一个包的时候，<code>npm</code>会下载该包的依赖包到<code>node_modules</code>目录中，如果本地安装下载的包带有<code>CLI</code>，<code>npm</code>会将它的脚本文件存放在<code>node_modules/bin</code>目录下，直接使用命令<code>npx 命令</code>即可调用。</p><p>比如<code>vite</code>、<code>webpack</code></p></div><h3 id="镜像源" tabindex="-1">镜像源 <a class="header-anchor" href="#镜像源" aria-label="Permalink to &quot;镜像源&quot;">​</a></h3><p>镜像源可以分为官方源、镜像源和私有源三种，<code>npm</code>在下载依赖时，会根据<code>registry</code>地址进行下载依赖，而<code>npm</code>的<code>registry</code>服务器位于国外，可能会受网速影响导致下载缓慢，所以通过切换一个更快的或者地理位置较近的镜像源，比如淘宝提供的镜像源地址<code>https://registry.npm.taobao.org</code>，该镜像包含了官方库中所有包的副本。</p><ul><li><code>npm config set registry 镜像源</code>：设置镜像源</li><li><code>npm config get registry</code>：查看当前镜像源</li></ul><p><code>npm</code>配置文件<code>.npmrc</code>能够影响镜像源的选择，系统中可能存在多个配置文件，这些配置文件被访问的优先级从高到底依次是：</p><ul><li>项目级的<code>.npmrc</code>文件：只作用在当前项目，跨项目生效。</li><li>用户级的<code>.npmrc</code>文件：<code>npm config get userconfig</code>可以看到存放的路径</li><li>全局级的<code>npmrc</code>文件：<code>npm config get globalconfig</code>可以看到存放的路径</li><li>内置的<code>npmrc</code>文件：不可更改的内置<code>npm</code>默认配置</li></ul><h3 id="工具" tabindex="-1">工具 <a class="header-anchor" href="#工具" aria-label="Permalink to &quot;工具&quot;">​</a></h3><ul><li><code>nrm</code>：镜像源管理工具</li><li><code>nvm</code>：<code>Nodejs</code>版本管理工具</li></ul><h2 id="版本号" tabindex="-1">版本号 <a class="header-anchor" href="#版本号" aria-label="Permalink to &quot;版本号&quot;">​</a></h2><p>版本号遵循语义化控制，它是由三个部分组成，通常表示为<code>主版本号.次版本号.修订号 x.y.z</code>：</p><ul><li>主版本号：当做了不兼容的<code>API</code>修改时，增加的主版本号，比如<code>Vue2</code>升级到<code>Vue3</code></li><li>次版本号：添加了向下兼容的功能，意味着新版本添加了新功能，但是不会破坏现有功能的使用。</li><li>修订号：当修改了一些向下兼容的问题，并不会影响现有功能时，增加的修订号。</li></ul><p>总结是重大更新增加主版本号，向下兼容新增功能增加次版本号，修复<code>bug</code>增加修订号</p><p>版本范围显示：</p><ul><li><code>^</code>：表示在主版本号非0的情况下，不修改主版本号，次版本号和修订号随意，比如<code>^2.2.1</code>表示<code>2.2.1 &lt;= 依赖版本 &lt; 3.0.0</code>版依赖包。</li><li><code>~</code>：表示在不改变主版本号和次版本号，<code>&gt;=</code>修订号，比如<code>~2.2.1</code>可以是<code>2.2.1，2.2.2,...，2.2.n</code></li><li><code>&lt;</code>：表示必须小于某个版本，比如<code>&lt;2.2.1</code>依赖的版本号必须要小于这个版本。</li><li><code>&lt;=</code>：表示必须小于等于某个版本。</li><li><code>&gt;</code>：大于某个版本。</li><li><code>&gt;=</code>：大于等于某个版本。</li><li><code>.x</code>：表示修订号的位置上出现了个<code>x</code>，比如<code>2.2.x</code>，依赖版本的范围表示<code>2.2.0 &lt;= 依赖版本 &lt;2.3.0</code></li><li><code>*</code>：表示任意版本</li><li><code>-</code>：表示一个范围，比如<code>2.2.1-2.3.1</code>表示<code>2.2.1 &lt;= 依赖版本 &lt;= 2.3.1</code></li></ul><h2 id="npx" tabindex="-1">npx <a class="header-anchor" href="#npx" aria-label="Permalink to &quot;npx&quot;">​</a></h2><p><code>npx</code>是一个命令行工具，在安装<code>npm</code>时，会随同它一起包含在内。</p><p>它用于直接执行<code>node_modules/.bin</code>中的可执行文件，无需全局安装。运行规则和<code>npm</code>是一致的，遵循的是<code>冒泡查找</code>，会在当前目录的<code>bin</code>中查找命令，如果没有会向上冒泡到全局的<code>node_modules</code>查找，如果还没有，就去下载这个包，然后执行命令，执行完毕后删除该包。</p><p>常见用途：</p><ul><li>测试尚未发布的包</li><li>执行本地包</li><li>运行一次性命令</li></ul><div class="language-shell vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 运行一个本地安装的包的命令</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">npx</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">package-nam</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">e</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 运行特定版本的包</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">npx</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">package-nam</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">e</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">versio</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">n</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 直接运行 GitHub 上的脚本</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">npx</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> github:</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">owne</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">r</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">/</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">rep</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">o</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>一般会执行创建项目的脚手架命令，比如<code>nestjs</code>的<code>npx nest new</code>，<code>react</code>的<code>npx create-react-app</code>。</p><p>如果想要编写一个可执行的包，需要在<code>package.json</code>中指定<code>bin</code>字段，指向可执行的脚本文件。</p><div class="language-json vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;name&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;test&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;version&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;1.0.0&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;bin&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    &quot;my-cli&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;./bin/index.js&quot;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 定义全局命令与入口文件</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>编写可执行脚本要在文件开头指定<code>Shebang</code>，指定用<code>Nodejs</code>执行</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">#!/usr/bin/env node</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ↑ Shebang 必须，指定用 Node.js 执行</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Hello test pck!&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div>`,35)]))}const g=s(l,[["render",d]]);export{k as __pageData,g as default};
